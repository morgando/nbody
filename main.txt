/**
 * Program simulates the evolution of a galaxy using difference equations to estimate
 * the x, y, and z positions and x, y, and z velocities of stars. Refer to the document “N-Body v1“ on Athena
 * to see these equations along with their derivations. In order to see translations of the difference equations
 * along with how they are implemented within this program, see the comments for the findNextVelocity and findNextPosition
 * methods in the Nbody class. 
 *
 * This file contains the following classes involved in the program in the same order they are listed:
 *
 * (1) The RunSimulation class contains the main method of the program which creates an object
 * of type Nbody. The user may specify a file name, delta t value, and simulation duration
 * in this call to the constructor.
 *
 * (2) The Nbody class contains the algorithm being used to run the simulation—check the comment for the Nbody constructor
 * to see a description of this algorithm.
 * 
 * (3) The Entity class represents the stars in the simulation. It contains methods that store, manipulate, and 
 * retrieve information about stars relevant to the simulation.
 *
 * (4) The Vector class facilitates the storage and manipulation of three-dimensional position
 * and velocity data. The position and velocity instance variables of Entity objects are objects of type Vector.
 * 
 * In order to run a simulation, the user must provide information about stars within the simulation 
 * in a file. To see specifications about how the file must be structured, look at the precondition
 * in the constructor for the Nbody class.
 *
 * Besides controlling the initial masses, positions, and velocities of stars in the simulation,
 * the user can customize the duration of the simulation and the length of time between subsequent
 * velocity/position estimations in the call to the Nbody constructor in the main method. 
 * Again, check the comment for the constructor of the Nbody class to see specifications about these parameters.
 *
 * @author Morgan Douglas
 * @version 01/13/18
 */

import java.io.IOException;

/**
 * RunSimulation contains the main method of the program which creates an object of type NBody,
 * starting the simulation. The user may input parameters in the call to the constructor
 * within the main method: the in-line comment for the call to the constructor explains
 * which parameters go where. 
 * 
 * @author Morgan Douglas
 * @version 01/13/18
 */
public class RunSimulation 
{
    /**
     * Constructs an object of type Nbody, starting simulation. User may edit parameters
     * within call to the constructor: read in-line comment for details and check comment
     * for the Nbody constructor within the Nbody class below for parameter specifications.
     *
     * @param args contains supplied command line arguments
     *
     * @throws NumberFormatException
     * @throws IOException
     */
    public static void main(String[] args) throws NumberFormatException, IOException
    { 
        Nbody galaxy = new Nbody(“data”, 8.6E4, 3.2E7); //creates Nbody object. Parameters represent name of file, time between
                                                        //estimations (s), and duration of simulation (s), respectively

        return;
    }

}

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.*;

/**
 * Runs galactic simulation using the methods described in the top-level comment. For more information about 
 * user-customizable parameters and the algorithm being used to run the simulation, look at this class’ constructor comment.
 * 
 * @author Morgan Douglas
 * @version 1/13/18
 */
public class Nbody 
{
    //instance variables dealing with the input file
    private File file;                               //contains information about the objects involved in the simulation
    private BufferedReader read;                     //used to read the file indicated by the user in the call to the constructor
    
    //instance variables dealing with time
    private Double simulationTime;                   //length of simulation in seconds
    private Double deltaT;                           //time between two subsequent velocity/position estimations, in seconds
    
    //instance variable used to store objects in simulation
    private ArrayList<Entity> entities;              //contains all Entities in the simulation
    
    //instance variable involved in collision handling
    private ArrayList<Entity> collisions;            //stores Entities that have collided so they may be merged                    
    
    //constants
    public final Double GRAV_FORCE=6.674E-11;        //represents gravitational force in (m^3)*(kg^-1)*(s^−2)
    public final Double METERS_IN_PARSEC=3.086E16;   //number of meters in one parsec
    public final Double KILOS_IN_SOLARMASS=1.989E30; //number of kilograms in one solar mass unit
    public final Double METERS_IN_KILOMETER=1000.;   //number of meters in a kilometer

    
    /**
     * Runs simulation. Extracts Entity information from user-indicated file and stores this information in the 
     * ArrayList entities. 
     * 
     * (A) loops through entities and estimates the next velocity of each Entity, then uses this
     * value to estimate the next position of each Entity. While making estimations, next velocity and next position Vectors
     * are stored in the nextVelocity and nextPosition instance variables of each Entity.
     * 
     * (B) the ArrayList collisions is checked for emptiness. If it is not empty, that means that
     * Entities have collided. In this case, the mass of one Entity will be set to the sum of the masses of
     * both Entities, while the other will be removed from the simulation. The nextVelocity Vectors (and therefore
     * the nextPosition Vectors, as well) of the collided Entities will already have been updated in accordance 
     * with the conservation of linear momentum for inelastic collisions in step A (check the comments for the 
     * findNextVelocity and mergedEntityVelocity methods to discover where and how this works, respectively).
     * 
     * (C) loops through entities and calls an update method contained within the Entity class for each. This
     * method will set Vectors that have been stored in nextPosition and nextVelocity to be set to the
     * current positions and velocities. Contains a statement that prints a String
     * representation of the current position of each Entity for graphing purposes--this statement may be 
     * modified by the user to something they find meaningful.
     * 
     * The process of estimating and updating continues until reaching a time duration defined by the user.
     * 
     * @param fileName the name of the file containing data regarding objects involved in simulation. Check precondition
     * to see how the file should be structured.
     * @param timeStep the amount of time between subsequent velocity/position estimations, in seconds.
     * @param duration the total amount of time the simulation is to run, in seconds.
     * 
     * @throws NumberFormatException
     * @throws IOException
     * 
     * @precondition fileName must reference a .txt file, however, the extension should not be included
     * in the command line. For example, a file "data.txt" would be entered as a parameter solely as "data"
     * 
     * File /must/ be structured as so, with data regarding different Entities on different lines:
     * 
     * mass, positionX, positionY, positionZ, velocityX, velocityY, velocityZ
     * 
     * Mass values must be given in solar mass, position values in parsecs, and velocity values in km/s
     */
    public Nbody(String fileName, Double timeStep, Double duration) throws NumberFormatException, IOException
    {
        deltaT = timeStep;                                           //sets deltaT to value specified by user   
        simulationTime = duration;                                   //sets simulationTime to value specified by user
        
        entities = new ArrayList<Entity>();                          //initializes ArrayList that will store all entities 
                                                                     //involved in simulation
        
        file = new File(fileName + ".txt");                          //creates new file from given fileName
        read = new BufferedReader(new FileReader(file));             //creates BufferedReader to parse file
        
        parseFile();                                                 //parses through file, creating Entity objects 
                                                                     //from data in file and adding them to entities
        
        collisions = new ArrayList<Entity>();                        //initializes collisions
        
                                                           
        for(Double t=0.; t<simulationTime; t+=deltaT) //runs the simulation for user-defined period of time
        {
            for(Entity j:entities)    //loops through Entity objects, estimating and storing
            {                         //next velocities and positions of each Entity
               
                j.storeNextVelocity(findNextVelocity(j));            //estimates and stores next velocity of entity
            
                j.storeNextPosition(findNextPosition(j));            //uses previously estimates velocity to estimate
                                                                     //next position of entity
            }
            
            if(!collisions.isEmpty()) //if collisions have occurred, updates the mass of one Entity to the sum of collided 
            {                         //Entities                       
                
                for(int i=0; i<collisions.size(); i+=2)
                {
                    collisions.get(i).setMass(collisions.get(i).mass //sets the mass of one Entity to the sum of the masses
                            + collisions.get(i+1).mass);             //of both Entities
                                        
                    entities.remove(collisions.get(i+1));            //removes the other Entity from the simulation  
                }
                
                collisions.clear();   //clears collisions after all collided Entities have been handled            
            }
            
            
            for(Entity j: entities) //updates velocity and position vectors for each Entity 
            {  
                j.update();                                          //calls Entity method that performs updates
                
                System.out.println(j.position.toString());           //prints Entity position in each dimension 
            }                                                        //for graphing purposes
                                                     
        } //runs the simulation for user-defined period of time
        
        return;
    }

    /**
     * Estimates the next velocity of an Entity object (after deltaT seconds) in 3 dimensions using the difference equation
     * [velocity of Entity j after deltaT time]=[Current velocity of Entity j] - [Summation],
     * where Summation = the sum of this computation for each Entity i, where i cannot equal Entity j:
     * 
     * [Mass of i]*[GRAV_FORCE]/([magnitude of (vector j - vector i)]^3)*deltaT*[vector j - vector i]
     * 
     * Checks if the magnitude of (vector j - vector i) equals zero for each Entity i. If so, the two Entities have collided
     * and are added to collisions so that their masses are updated properly later in the simulation. In this case,
     * the returned next velocity Vector will be in accordance with the conservation of linear momentum for inelastic collisions.
     * An explanation of the equation used to compute this Vector can be found in the comment for the mergedEntityVelocity
     * method.
     * 
     * @param j represents the Entity object for which next velocity is being estimated
     * 
     * @return a Vector containing estimations of the next velocities of the Entity object j in the x, y, and z dimensions.
     */
    public Vector findNextVelocity(Entity j)
    {
        Vector summation = new Vector(0.,0.,0.);     //initializes summation to zero in all dimensions
        
        for(Entity i:entities) //loops through entities, each time performing a computation, the value of which is added 
        {                      //to summation, which is part of the difference equation described in the method comment

            if(i!=j)           //adds to summation only if Entity i does not equal Entity j
            {
                Vector diff = j.position.subtract(i.position);
                Double magnitude=diff.magnitude();
                
                if(magnitude==0.0) //returns velocity vector in keeping with the conservation of linear momentum 
                {                  //for inelastic collisions if i and j have the same position in three dimensions.
                                   //Adds i and j to collisions so their masses can be updated later
                    
                    collisions.add(i);                      //adds i and j to collisions
                    collisions.add(j);
                    
                    return mergedEntityVelocity(i, j);      //returns next velocity of merged Entity
                    
                }
                else //if i and j do not have the same position, performs computation and adds its value to summation
                {
                    summation.addTo(diff.multiply(((i.mass*GRAV_FORCE)/Math.pow(magnitude, 3))*deltaT));
                }
            }
        } //calculates the value of the summation 
        
        return j.velocity.subtract(summation);      //subtracts the computed value of summation from the current
                                                    //velocity of Entity j to estimate j's velocity after deltaT time
    }
    
    /**
     * Estimates the next position of an Entity object (after deltaT seconds) using the difference equation:
     * [position of j after deltaT seconds]=[current position of j] + [velocity of j after deltaT seconds]*deltaT
     * 
     * @param j represents the Entity object for which next position is being estimated
     * 
     * @return a Vector containing estimations of the next positions of the Entity object j in the x, y, and z dimensions
     */
    public Vector findNextPosition(Entity j)
    {
        return j.position.add(j.nextVelocity.multiply(deltaT));                 //computes next position Vector
    }
    
    /**
     * Computes the velocity (in x, y, and z dimensions) of a new more massive Enitity that results 
     * from the inelastic collision of Entities i and j. Stores this velocity as the next velocity of Entity j.
     * 
     * This velocity is computed using the equation below:
     * 
     * ([mass of i]*[velocity vector of i] + [mass of j]*[velocity vector of j])/([mass of i] + [mass of j])
     * 
     * The above equation conserves linear momentum. (this information can be found in the "N-Body v1" document on
     * Athena)
     * 
     * @param i an Entity object
     * @param j an Entity object
     * 
     * @precondition i and j have the same position in the x, y, and z dimensions
     * 
     * @return a Vector object representing the velocity of the new Entity that results from the merging of i and j
     */
    public Vector mergedEntityVelocity(Entity i, Entity j)
    {
        return (i.velocity.multiply(i.mass).add(j.velocity.multiply(j.mass))    //computes and sets new velocity Vector 
                .divide((i.mass+j.mass)));                                      //using equation described in method comment                                                                                                          
    }
    
    /**
     * Constructs Entity objects using information in the file indicated by the file name passed in the
     * call to the Nbody constructor. Adds new Entity objects to entities.
     * 
     * @throws NumberFormatException
     * @throws IOException
     */
    public void parseFile() throws NumberFormatException, IOException
    {
        try
        {
            while(read.ready()) //parses through file and creates Entity objects using information in file
            {
                String line = read.readLine();                      //reads single line of file
            
                Double mass=0.;                                     //initializes local variables that will temporarily store
                Vector positions=new Vector(0.,0.,0.);              //information from file before Entity objects are created
                Vector velocities=new Vector(0.,0.,0.);
            
                for(int i=0; i<3; i++)
                {
                    int index = line.indexOf(",");                                          //extracts next number in line
                    String lineComp = line.substring(0, index);                           
                    Double comp = Double.valueOf(lineComp);
                
                    if(i==0)       //extracts mass from file information
                    {
                        mass = comp*KILOS_IN_SOLARMASS;                                     //converts mass from solar mass
                        line = line.substring(index+1);                                     //to kilograms
                    
                    }
                    else if(i==1)  //constructs position Vector from file information
                    {
                        Double positionOne = comp;                                          //extracts x-component of position
                        line = line.substring(index+1);
               
                        int indexSpace2 = line.indexOf(" ");                                //extracts y-component of position
                        int indexComma2 = line.indexOf(",");
                        String lineComp2 = line.substring(indexSpace2+1, indexComma2);
                        Double comp2 = Double.valueOf(lineComp2);
                        Double positionTwo = comp2;
                        line = line.substring(indexComma2+1);
                        
                        int indexSpace3 = line.indexOf(" ");                                //extracts z-component of position
                        int indexComma3 = line.indexOf(",");        
                        String lineComp3 = line.substring(indexSpace3+1, indexComma3);
                        Double comp3 = Double.valueOf(lineComp3);
                        Double positionThree = comp3;
                        
                        positions = new Vector(positionOne, positionTwo, positionThree);   //constructs position vector
                        
                        positions = positions.multiply(METERS_IN_PARSEC);                  //converts positions from parsecs 
                                                                                           //to meters
                        line = line.substring(indexComma3+1);                              
                    }
                    else           //constructs velocity Vector from file information
                    {
                        Double velocityOne = comp;                                         //extracts x-component of velocity
                        line = line.substring(index+1);
                        
                        int indexSpace4 = line.indexOf(" ");                               //extracts y-component of velocity
                        int indexComma4 = line.indexOf(",");
                        String lineComp4 = line.substring(indexSpace4, indexComma4);
                        Double comp4 = Double.valueOf(lineComp4);
                        Double velocityTwo = comp4;                                    
                        line = line.substring(indexComma4+1);
                        
                        int indexSpace5 = line.indexOf(" ");                               //extracts z-component of velocity
                        String lineComp5 = line.substring(indexSpace5);
                        Double comp5 = Double.valueOf(lineComp5);
                        Double velocityThree = comp5;               
                        
                        
                        velocities = new Vector(velocityOne, velocityTwo, velocityThree);  //constructs velocity Vector
                        
                        velocities = velocities.multiply(METERS_IN_KILOMETER);             //converts velocities from km/s to m/s                     
                    }
                } 
                
                Entity ent = new Entity(mass, positions, velocities); //uses extracted information to create Entity object
            
                entities.add(ent);                                    //adds newly created Entity to entities
                
            } //parses through file and creates Entity objects using information in file
            
            return;
        }
        catch (Exception e)
        {
            e.printStackTrace();                                      //prints what exception is and line it occurred on
            return;                                                   //and terminates simulation
        }
    }
}

/**
 * Entity objects represent stars in the simulation. 
 * Stores and manipulates mass/position/velocity information about stars.
 * 
 * @author Morgan Douglas
 * @version 01/13/18
 */
public class Entity 
{
    protected Double mass;          //the mass of the Entity object in kg
    protected Vector position;      //the position of the Entity object in x, y, and z dimensions in m
    protected Vector velocity;      //the velocity of the Entity object in x, y, and z dimensions in m/s

    protected Vector nextPosition;  //the next position of the Entity object in x, y, and z dimensions in meters
    protected Vector nextVelocity;  //the next velocity of the Entity object in x, y, and z dimensions in m/s
    
    /**
     * constructs an Entity object
     * 
     * @param m the mass of the Entity object in kilograms in kg
     * @param pos the position of the Entity object in x, y, and z dimensions in m
     * @param vel the velocity of the Entity object in x, y, and z dimensions in m/s
     */
    public Entity(Double m, Vector pos, Vector vel)
    { 
        mass=m;                                 //initializes mass, position, and velocity
        position=pos;                           //to user-defined values
        velocity=vel;
        
        nextPosition=new Vector(0.,0.,0.);      //initializes nextPosition and nextVelocity
        nextVelocity=new Vector(0.,0.,0.);      //to Vectors with zero in 3-dimensions.
 
        
        return;
    }

    /**
     * sets Vectors representing the Entity object's next position and next velocity to the
     * Entity object's current position and current velocity
     */
    public void update()
    {
        position=nextPosition;
        velocity=nextVelocity;
        
        return;
    }

    /**
     * stores the next position of the Entity object
     * 
     * @param pos a Vector object representing the Entity object's next position in 3 dimensions in m
     */
    public void storeNextPosition(Vector pos)
    {
        nextPosition=pos;
        
        return;
    }

    /**
     * stores the next velocity of the Entity object
     * 
     * @param vel a Vector object representing the Entity object's next velocity in 3 dimensions in m/s
     */
    public void storeNextVelocity(Vector vel)
    {
        nextVelocity=vel;
        
        return;
    }

    /**
     * sets the mass of the Entity object to m
     * 
     * @param m the value to which the mass of the Entity object is to be set in kg
     */
    public void setMass(Double m)
    {
        mass=m;
        
        return;
    }

    /**
     * sets the velocity of the Entity object to m
     * 
     * @param vel the Vector object to which the velocity of the Entity object is to be set in m/s
     */
    public void setVelocity(Vector vel)
    {
        velocity=vel;
        
        return;
    }
}

/**
 * Stores the x, y, and z components that make up a vector.
 * Contains several methods that facilitate computation involving Vector objects with both 
 * other Vector objects and scalar values.
 * 
 * This is a minimal Vector class. In the future, a user should consider adding the following
 * methods:
 * 
 * A setter method that changes x, y, and z values to new values provided as parameters.
 * 
 * Multiplication, division, and subtraction methods that modify instance variables instead 
 * of creating and returning new Vector objects. Could be named 
 * (multiply/divide/subtract)Internal in keeping with the naming of the similar
 * addInternal method.
 * 
 * 
 * @author Morgan Douglas
 * @version 01/13/18
 */
public class Vector 
{
    private Double x;       //stores x component of vector
    private Double y;       //stores y component of vector
    private Double z;       //stores z component of vector

    /**
     * Constructs a Vector object
     * 
     * @param xVal the x component of the vector
     * @param yVal the y component of the vector
     * @param zVal the z component of the vector
     */
    public Vector(Double xVal, Double yVal, Double zVal)
    {
        x=xVal;              //stores x, y, and z values provided
        y=yVal;
        z=zVal;
        
        return;
    }
    
    /**
     * @return the x component of the Vector object
     */
    public Double getX()
    {
        return x;
    }
    
    /**
     * @return the y component of the Vector object
     */
    public Double getY()
    {
        return y;
    }
    
    /**
     * @return the z component of the Vector object
     */
    public Double getZ()
    {
        return z;
    }
   
    /**
     * adds another Vector object v to the Vector object. Modifies instance variables to represent output of summation.
     * 
     * @param v another Vector object being added to the Vector object
     */
    public void addInternal(Vector v)
    {
        x+=v.getX();        //increments x, y, and z instance variables by x, y, and z values of Vector v
        y+=v.getY();
        z+=v.getZ();
        
        return;
    }
    
    /**
     * adds another Vector object v to the Vector object. Instead of modifying instance variables, creates a new
     * Vector with x, y, and z values equal to the results of the summation.
     * 
     * @param v the another Vector object being added to the Vector object
     * @return a Vector object resulting from the addition of the Vector object with another Vector object v
     */
    public Vector add(Vector v)
    {
        return new Vector(x+v.getX(), y+v.getY(), z+v.getZ());
    }
    
    /**
     * performs multiplication between a scalar and a Vector object.
     * 
     * @param amt the scalar to which the Vector object is being multiplied
     * @return a new Vector object resulting from the multiplication of two vectors
     */
    public Vector multiply(Double amt)
    {
        return new Vector(x*amt, y*amt, z*amt);
    }
    
    /**
     * performs division of a scalar from a Vector object
     * 
     * @param amt the scalar that the Vector object is being divided by
     * @return a new Vector object representing the result of dividing the Vector object by amt
     */
    public Vector divide(Double amt)
    {
        return new Vector(x/amt, y/amt, z/amt);
    }
    
    /**
     * @return the magnitude of the Vector object
     */
    public Double magnitude()
    {
        return Math.sqrt(x*x+y*y+z*z);
    }
    
    /**
     * subtracts two Vectors
     * 
     * @param v another Vector that is to be subtracted
     * @return a new Vector resulting from the subtraction of two Vectors
     */
    public Vector subtract(Vector v)
    {
        return new Vector(x-v.getX(),y-v.getY(),z-v.getZ());
    }

    /**
     * @return a String representation of the Vector object, where x, y, and z values are separated by TABs
     */
    public String toString()
    {
        return x + "\t" + y + "\t" + z;
    }
}


